[
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/",
	"title": "Terraform Primer",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Terraform Primer Before diving into configuraiton code, it is good to understand the fundamentals of Terraform. In this chapter you will learn the objectives of Infrastructure as Code, the various components that make up the Terraform toolset, and how Terraform can be used to manage infrastructure.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/basics/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Getting started This portion of the documentation contains several preparatory steps that you must complete in order to be successful in the lab. Prior to attempting to start this lab, be sure that you have received an email or Webex message with the following information:\n lab username (ending with auslab.cisco.com) lab password start and end time for your lab URL for remote access (Guacamole)  "
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/infrastructure_as_code/",
	"title": "Infrastructure as Code",
	"tags": [],
	"description": "",
	"content": "Infrastructure as Code (IaC) allows you to document the configuration needs of your infrastructure through a vendor agnostic language vs using a device specific graphical/command line interface. Imagine a sysadmin needs to configure their vCenter/ESXi cluster including data centers, clusters, networks, and VMs. One option would be to click through the GUI to configure each of the required settings. Not only does this take time, but it likely introduces configuration drift as individual settings are configured over the lifetime of the platform.\nIaC allows you to build, change, and manage your infrastructure in a safe, consistent, and repeatable way by defining resource configurations that you can version, reuse and share. Recording the desired configuration settings in a file and using an IaC tool eliminates the need to click through a GUI, thus reducing the time to deployment. Additionally, the tool can monitor the infrastructure (e.g vCenter or Intersight) and ensure the desired configuration in the file matches the infrastructure\nAdditional benefits of an IaC operational practice include:\n Reduced time to deployment Eliminate configuration drift (reduced risk) Increase team collaboration Accountability and change visibility Manage more than a single product  Hashicorp Terraform  Terraform is HashiCorpâ€™s infrastructure as code tool used for building, changing, and versioning infrastructure safely and efficiently. It lets you define resources and infrastructure in human-readable, declarative configuration files and makes it easy to manage the lifecycle of changes applied to that infrastructure.\nTerraform provides a well documented, vendor agnostic, schema-driven approach to interacting with various infrastructure APIs and underlying capabilities. This approach makes Terraform a good tool of choice for managing any modern API driven infrastructure.\nThe remainder of this chapter will focus on the core concepts of Terraform along with it\u0026rsquo;s various consumption models.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/tf_cloud/github_repo/",
	"title": "Migrate to VCS",
	"tags": [],
	"description": "",
	"content": "Push your configuration code to GitHub Recall that one of the early steps you followed in creating the project directory was to clone a repository from GitHub. That means that your current project directory already has a git configuration. You might have noticed that some of your files in vsCode are colored green and have a \u0026ldquo;U\u0026rdquo; next to them as shown in the image below. vsCode is well integrated with git and is highlighting files that are not being tracked by git. Files not colored are either unchanged or listed in the .gitignore file.\nThe first step to using Terraform with a version control system (VCS) is to push your configuration to GitHub. In this section of the lab, you will push your configuration files to GitHub.\nSteps:\n Click on the \u0026ldquo;Source Control\u0026rdquo; icon in the left navigation of vsCode as shown in the image below. In the source control view, you will be able to interact with both git and GitHub using the vsCode GUI instead of typing commands at the terminal. Click on the ellipses (...) in the source control window to expose the available commands as shown in the image below. Choose the command \u0026ldquo;Stage All Changes\u0026rdquo; from the \u0026ldquo;Changes\u0026rdquo; menu as shown in the image below.  Notice that your files now show up as \u0026ldquo;Staged Changes\u0026rdquo;. They are not yet committed. Enter a comment in the \u0026ldquo;Message\u0026rdquo; field as shown in the image below. You can enter any comment you choose. Click the checkmark above the \u0026ldquo;Message\u0026rdquo; field to commit these staged changes. You can optionally click on the ellipses and choose the command \u0026ldquo;Commit\u0026rdquo; from the \u0026ldquo;Commit\u0026rdquo; menu.  Click on the ellipses (...) in the source control window and choose the Push command. This will push your latest commit to GitHub. Notice that there are no more files shown in this view of vsCode. The source control view is designed to highlight changes that are not committed but there are none. Click on the Explorer icon in the left navigation of vsCode to view to your files.  Use the bookmark in the Chrome browser for GitHub to go to your repository on GitHub. Confirm that your files are there with your commit message. Keep in mind that some files like the README.md and .gitignore were created for you and will have a different commit message.  Your configuration code is now in GitHub. Your teammates who are authorized to write to your repository could clone the repository, make edits, and push changes.\nPut Terraform Cloud in VCS mode You have been using Terraform Cloud in Remote CLI mode, where your local configuration controls Terraform. You will now put Terraform Cloud in VCS mode, where it will retrieve configuration files from your GitHub repository any time that changes are pushed to the repository.\nSteps:\n Use the bookmark the Chrome browser to browse to Terraform Cloud. If you are asked to authenticate, remember to use SSO. In your workspace, go to the Settings menu and choose Version Control as shown in the image below.  Click on Connect to version control as shown in the image below to start the wizard for connecting to a GitHub repository.  A version control workflow is more common than a CLI-driven workflow (which is what you did in the previous section of this lab). Click on Version control workflow.  Choose your version control provider. A relationship has already been established (through certificate exchange) between the Wookie Labs Terraform Cloud organization and the Wookie Labs GitHub organization. This was done for you. Only one GitHub organization was linked, so select that organization.  The Wookie Labs GitHub organization has many repositories. It is important that you select the repository for your user account. Click wookie-labs/iac-user-. It is possible for you to select the wrong repository, which will result in you attempting to execute another user\u0026rsquo;s configuration. You don\u0026rsquo;t have that other user\u0026rsquo;s credentials, so the configuration will fail. Be careful and select your user\u0026rsquo;s repository.  You do not have to make any changes on the confirmation screen. Click Update VCS settings.  Confirm a run has started Completing the steps above will automatically trigger Terraform Cloud to perform a Terraform \u0026ldquo;plan\u0026rdquo; for the configuration in your GitHub repository. The configuration files should already match the current configuration in Intersight since you performed a tf apply in Remote CLI mode before pushing all of your code to GitHub. In this section, you will confirm that a plan was started automatically and that no changes were detected by Terraform.\nSteps:\n In Terraform Cloud, click on the Overview tab in your workspace. If you get there quickly enough, you will see that a run is in the planning phase. Otherwise, you will see a status of \u0026ldquo;Planned and finished\u0026rdquo;. In either case, notice that the name of the run is identical to the commit message you used when committing your code to GitHub.  Click See details. When you scroll to the bottom, you should see that plan finished, but no changes are required because \u0026ldquo;Your infrastructure matches the configuration.\u0026rdquo;  Congratulations! You have pushed your configuration files to GitHub and migrated Terraform Cloud from Remote CLI mode to VCS mode. In VCS mode, it sources its configuration files from GitHub.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/remote_cli/specify_remote/",
	"title": "Change backend",
	"tags": [],
	"description": "",
	"content": "So far in this lab you have been using the \u0026ldquo;local backend\u0026rdquo; for Terraform. In other words, you\u0026rsquo;ve been using your locally-installed instance of Terraform to execute your configuration. Using the local backend is the default behavior and does not require any additional configuration.\nIn this portion of the lab, you will start using a remote backend. This means your local configuration files will actually be executed by Terraform Cloud rather than your local instance of Terraform. This does require a few updates to your configuration files, your local environment, and Terraform Cloud.\nTo read more about backends, go here.\nAuthenticate to Terraform Cloud Steps:\n Browse to https://app.terraform.io. There is also a bookmark in the Chrome browser for Terraform Cloud. Click Sign in with SSO as shown in the image below.  Specify the organization name as \u0026ldquo;Wookie-Labs\u0026rdquo; (not case-sensitive) as shown in the image below and click Next.  You may be redirected to authenticate against the Active Directory server again or you may not depending on how much time has elapsed since your last authentication. If you see the screen below, enter the username and password presented to you for this lab. If you do not see this screen, proceed to the next step.  Once logged in, you will see a screen listing the workspaces to which you belong as shown below. You should see only one. Click on the workspace name.  The Overview tab of the workspace should look similar to the image below (you can click to enlarge the image). It gives you the instructions for connecting to Terraform Cloud in Remote CLI mode. Notice the example code provided on that page. Copy that code.  Create a file in your project directory called backend.tf and paste the code you just copied. It should look similar to the snippet below. Save the file.  terraform { backend \u0026#34;remote\u0026#34; { hostname = \u0026#34;app.terraform.io\u0026#34; organization = \u0026#34;Wookie-Labs\u0026#34; workspaces { name = \u0026#34;iac-user-{{ pod }}\u0026#34; } } } Connect to the remote backend The next step is to retrieve an API token from the remote backend (Terraform Cloud) so that you don\u0026rsquo;t have to enter your username and password for every Terraform run.\nSteps:\n In the vsCode terminal, execute the command tf login. You will see a message indicating that Terraform will request an API token using your browser (as shown in the image below). Type \u0026ldquo;yes\u0026rdquo; to confirm.  You just authenticated to Terraform Cloud in the previous section, so you likely will not have to do that again. If a long time has passed since your login to Terraform Cloud, you may need to go through the SSO steps outlined in the section above. You will be asked to provide a description for the token that will be issued to you from the Terraform Cloud as shown in the image below. Use any description you like and click Create API token.  The API token granted to you by Terraform Cloud will be displayed as shown in the image below. Click the copy icon next to the token.  In the vsCode terminal, paste the token where the Terraform login prompt is requesting it. Note that this is considered a sensitive value, so it will not be echoed to the screen when you paste it. It might appear that nothing has happened, but you should only paste once. It is common to mistakenly paste it more than once, so it is recommended to use the paste command from the \u0026ldquo;Edit\u0026rdquo; menu in vsCode rather than attempting to use keyboard shortcuts or right-click actions.  If you are successful, you will see a message that says \u0026ldquo;Welcome to Terraform Cloud!\u0026rdquo; If you are unsuccessful, you will see an error stating the token is invalid and you should repeat the steps in this section starting with tf login.\nInitialize remote backend You used the command tf init in the previous chapter of this lab guide to initialize the local backend. The initialization process performs several one-time tasks such as downloading the version of any providers specified in your configuration. In this section of the lab, you will perform that same initialization for the remote backend.\nSteps:\n From the vsCode terminal, execute the command tf init. Notice the confirmation message asks if you want to copy the existing state file to the new backend. Type \u0026ldquo;yes\u0026rdquo; to confirm.  Browse to Terraform Cloud at https://app.terraform.io/. There is also a bookmark for Terraform Cloud in the Chrome browser of the Windows host. If prompted for credentials, follow the previous instructions of selecting SSO for login. Click on your workspace and then click on the States tab as shown below. Click on the new state that has been generated. You will see your state file and should see your NTP policies there. You must now delete your local state file. From vsCode, delete the file named terraform.tfstate. Keeping the local state file will cause problems during the next part of the lab where you will execute the configuration from Terraform Cloud. Note that you can keep the local backup of the state file named terraform.tfstate.backup if you like.  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. backend.tf terraform { backend \u0026#34;remote\u0026#34; { hostname = \u0026#34;app.terraform.io\u0026#34; organization = \u0026#34;Wookie-Labs\u0026#34; workspaces { name = \u0026#34;iac-user-{{pod}}\u0026#34; } } }   myvalues.auto.tfvars policy_name_prefix = \u0026#34;iac-lab\u0026#34; policy_description = \u0026#34;created by Terraform\u0026#34; east_timezone = \u0026#34;America/New_York\u0026#34; west_timezone = \u0026#34;America/Los_Angeles\u0026#34;   ntp.tf resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;west\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-west\u0026#34; description = var.policy_description enabled = true timezone = var.west_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }   outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid } output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{ pod }}\u0026#34; }   variables.tf variable \u0026#34;policy_name_prefix\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;policy_description\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;west_timezone\u0026#34; { description = \u0026#34;timezone used for west NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;intersight_api_secret\u0026#34; { type = string default = \u0026#34;\u0026#34; } variable \u0026#34;intersight_api_key\u0026#34; { type = string default = \u0026#34;\u0026#34; }   Congratulations! You have successfully configured Terraform to use a remote backend. In other words, you have successfully configured Terraform to execute your configuration from the cloud rather than from your local machine. You have also successfully transferred the current state of your configuration to the cloud.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/open_source/first_plan/",
	"title": "Basic validation",
	"tags": [],
	"description": "",
	"content": "In this section of the lab, you will create a very basic Terraform configuration. The goals of this section are to:\n teach you an efficient way to find content in the Terraform docs validate that your credentials are correct  Create a simple HCL file HashiCorp Configuration Language (HCL) files look like a mix between JSON and YAML as you will see momentarily. As discussed in Terraform Primer \u0026gt; Basic validation, Terraform will evaluate all the configuration files in your project directory and treat them as a single document. For the purposes of this lab, you will not have a nested folder structure and your project directory will contain your root module. The names of the files do not matter as Terraform inspects all .tf and .tfvars files at the root level of the project directory.\nSteps:\n In vsCode, hover your mouse over the file tree or click inside the blue box shown in the image below. This will bring up the quick controls in vsCode to create a new file. Click on the icon to create a new file as shown in the image below and name the file providers.tf. Again, the name doesn\u0026rsquo;t actually matter but this lab will attempt to guide you through best practices. When your configuration grows, it is much easier to manage with multiple files each named appropriately.  You will start with the Intersight Terraform provider. To determine how to use the provider, search the internet for cisco intersight terraform provider and you will find this page on the Terraform Registry. There is also a bookmark in your browser for the Terraform Registry if you need to return to that page at any time. Look around the Intersight provider page on the Terraform Registry. Notice that the top downloaded modules are listed here. Notice that there is a a tab for Documentation and a button labeled Use Provider. Click on Use Provider.  Copy the code snippet from the Use Provider dropdown and paste it in your configuration file providers.tf. Save the file. If you\u0026rsquo;re unfamiliar with vsCode, unsaved files are marked with a circle next to the filename on the tab as shown in the image below. If you run a Terraform command in this lab and do not get the expected results, make sure that you have saved all of your changes. You can select Save All from the vsCode File menu if you have modified several files.  Save the file and then run tf init from the terminal. You should see messages about Terraform installing the Intersight provider followed by a message that says \u0026ldquo;Terraform has been successfully initialized!\u0026rdquo;  Pause for a moment and consider what is defined in your single configuration file and what effect the tf init command had.\n The configuration file specifies that the Intersight provider is required as well as the version number for that provider. The configuration file specifies all configuration options for that provider in the \u0026ldquo;provider\u0026rdquo; block. In this case, no options are specified here as you already specified those options (credentials and endpoint) as environment variables in an earlier step of this lab. You will add configuration options to this block later in the lab. The tf init command initialized the \u0026ldquo;backend\u0026rdquo;. In Terraform, the backend is the location that will execute the configuration, which for now is the Windows 10 host. Notice that there is now a folder called .terraform in your project directory and the Intersight provider has been downloaded to that directory.  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   Add a data source to the configuration The project that you initialized does not yet have any actual configuration code in it so Terraform has not yet attempted to authenticate to Intersight.\nIn this section of the lab, you will fetch an existing object from Intersight as a data source. This will require that Terraform successfully authenticate to Intersight. You will need the MOID of an organization in order to create any policy, so the first thing you will do is to retrieve that organization\u0026rsquo;s MOID.\nSteps:\n Go back to the Intersight provider webpage on the Terraform registry and click the Documentation tab. Search for the term \u0026ldquo;organization\u0026rdquo; as shown in the image below (you can click on any image in this lab guide to zoom in). Notice there is a data source called intersight_organization_organization. Click on that data source to inspect its documentation. The documentation shows that this source has a field called \u0026ldquo;name\u0026rdquo;.  Create a new file called sources.tf and add the following code snippet to that file. Remember that you could also simply add this code snippet to the end of your providers.tf file instead of creating a new file, but it is advisable to organize your code into separate files. Don\u0026rsquo;t forget to save the file.  data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; } Run the command tf apply in the vsCode terminal. You should see a message that says \u0026ldquo;Apply complete! Resources: 0 added, 0 changed, 0 destroyed.\u0026rdquo; There is now a file named terraform.tfstate in the project directory. This is the state file. This file contains details about every resource and data source created and consumed by your configuration. You will look through this state file in the next section of the lab.  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; }   Review the state file In this section, you will review the relatively simple state file for this lab. At this point in the lab, the configuration is simple, and the state file represents the current configuration. The state file is very important to Terraform. It\u0026rsquo;s primary purpose is to bind real world resources (such as a policy or a virtual machine) to blocks in your configuration code. You can read more here.\nIf you use Terraform to create new objects in your infrastructure and then misplace the state file, Terraform will have no knowledge of those objects it once created and will be unable to edit or delete them. In this portion of the lab, you are working with a local state file, but the importance of this file necessitates backing it up to another device or keeping it in a source control system. Later in this lab, you will learn how to transfer your state file to Terraform Cloud for secure and reliable access and storage of the file.\nOpen the terraform.tfstate file in vsCode. If you are familiar with the JSON format, it will look familiar to you. Refer to the state file and the truncated snippet of a state file below when reading the following points.\n The \u0026ldquo;outputs\u0026rdquo; field is empty for now because you have not defined any outputs. You will do that in the next section of the lab. Outputs can save you the trouble of searching through the state file to find a value. The \u0026ldquo;resources\u0026rdquo; section is a JSON list that only contains only one element for now because you have only specified one element: your organization. The \u0026ldquo;mode\u0026rdquo; for this one resource is \u0026ldquo;data\u0026rdquo; because it is an existing object in the environment. If your configuration had instead created a new organization, it would be listed as \u0026ldquo;mode\u0026rdquo;: \u0026ldquo;managed\u0026rdquo;. Notice the \u0026ldquo;type\u0026rdquo; and \u0026ldquo;name\u0026rdquo; fields combined uniquely point to one block (a data block in this case) in your configuration. The \u0026ldquo;attributes\u0026rdquo; section for any resource returns attributes (for lack of a better term) that are specific to the provider. The attributes you see here are the ones returned by the Intersight provider for Terraform. One of the attributes returned by the Intersight provider is \u0026ldquo;results\u0026rdquo; (a list) because some Intersight queries could return more than one object. Your query, which searched for an organization by name, returned only one object. The \u0026ldquo;moid\u0026rdquo; of organization is one of the properties returned for your organization. Notice there are other properties like \u0026ldquo;description\u0026rdquo; and \u0026ldquo;create_time\u0026rdquo;.  \u0026#34;outputs\u0026#34;: {}, \u0026#34;resources\u0026#34;: [ { \u0026#34;mode\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_organization_organization\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;iac\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;results\u0026#34;: [ { . . . \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3a8\u0026#34;, Browsing the state file in a moderately complex configuration can be overwhelming, so in the next section you will learn how to display a value on the screen after a Terraform apply operation.\nAdd an output to the configuration You will add an output statement to your project to display results from the configuration. Documentation on the format of the HCL \u0026ldquo;output\u0026rdquo; statement is here. Additionally, the Intersight provider documentation for intersight_organization_organization states that accessing the property of a data source is done with the format:\ndata.intersight_organization_organization.\u0026lt;custom_name\u0026gt;.results[i].\u0026lt;propertyname\u0026gt;\nThe above syntax should also make sense to you based on your walkthrough of the structure of the state file.\nThis format is what you will use for the \u0026ldquo;value\u0026rdquo; of your output. The propertyname will be \u0026ldquo;moid\u0026rdquo; and the value for i will be zero because you are retrieving the first (and only) result.\nSteps:\n Create a new file named outputs.tf and add the code snippet below to the file. Don\u0026rsquo;t forget to save the file. Run the command tf apply in the terminal and answer \u0026ldquo;yes\u0026rdquo; to confirm executing the Terraform configuration. You should see your organization\u0026rsquo;s MOID as an output in the terminal.  output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid }  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; }   Congratulations! You have created your first Terraform configuration. It doesn\u0026rsquo;t actually configure anything yet, but so far you have learned and proven:\n Terraform resource, data, and output blocks can be distributed across multiple files. Names of HCL files do not matter. Existing resources can become part of your configuration through data blocks. The state file is of immense importance and can be read with a text editor. Values of any resource in your configuration can be displayed on the screen using an output block.  "
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/open_source/",
	"title": "Terraform open source",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Terraform open source This chapter of the lab focuses entirely on Terraform \u0026ldquo;open source\u0026rdquo; (OSS) \u0026ndash; the free command line version of Terraform. Terraform can be installed on a Mac using brew, Windows PC using Chocolatey, or many different platform via direct download from here. For the purposes of this lab, Terraform has already been installed for you as you discovered in the previous section when you verified the Terraform version.\nYou should be familiar with the purpose of providers and modules in Terraform. If you are not and want to do some additional reading, look here.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/basics/verify_environment/",
	"title": "Verify connectivity",
	"tags": [],
	"description": "",
	"content": "In this section of the lab you will\n verify connectivity and credentials for the Windows 10 host you will use for the lab verify credentials for Cisco Intersight  Guacamole Guacamole is an open source project that provides remote access such as RDP and SSH over HTTPS. If you are unfamiliar with Guacamole, please read the Guacamole page in the Resources section of this guide before proceeding.\nSteps:\n Browse to the Guacamole URL provided to you in the lab details email. Enter the username and not full email address provided to you as shown in the figure below. Enter the password provided to you. Click Login  You will be connected to the RDP (remote desktop protocol) session for a Windows 10 host in the lab. Complete the entire lab from this RDP session unless instructed otherwise.\nNOTE: You may find it easier to open this lab guide inside the Guacamole session if you have trouble with copy and paste.\nIntersight Cisco provides options that allow entities to host their own private instance of Intersight, but this lab will rely on the public instance of Intersight at https://intersight.com. Execute the following steps from within the Windows 10 RDP session.\nSteps:\n Click on the following link to take you to https://intersight.com. There are two login options available for Intersight. Use the SSO login option on the right. Enter the email address provided to you for this lab as shown in the image below. Click Sign In with SSO.  You will be redirected to authenticate to the ADFS (Microsoft Active Directory) server for the lab. In this step, it is important to enter just the username and not the full email address as shown in the figure below. Enter the password provided to you. Click Sign In.  Once authenticated, you will be logged into Intersight where you have administrator privileges within a single organization. Do not click on the Workload Optimizer widget tab as you do not have Workload Optimizer privileges and will be locked out of your Intersight account.\nCongratulations! You have successfully verified connectivity to the lab environment and Intersight. Logging into Guacamole gives you access to a desktop in the lab environment, and logging into Intersight shows that you have the right credentials.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/basics/vscode/",
	"title": "Configure the IDE",
	"tags": [],
	"description": "",
	"content": "This lab will use Microsoft Visual Studio Code (vsCode) for the integrated development environment (IDE). This is a very popular and free IDE that has many free extensions for different programming languages. In this section of the lab, you will configure vsCode for use with Terraform.\nInitialize the project directory In this portion of the lab, you will clone a GitHub repository to use as your project directory. It may seem unusual to clone a nearly empty repository, but this specific repository will be important later in the lab when you migrate to Terraform Cloud as a link has been established between your repository and the Terraform Cloud organization. This will be explained in detail later in the lab when it is more relevant. For now, know that there is a reason to clone a nearly empty repository rather than start with an empty folder for this lab.\nSteps:\n From the Windows 10 host desktop, click on the Visual Studio Code icon to open vsCode. From vsCode, either press Ctrl+Shift+P or select \u0026ldquo;Command Palette\u0026hellip;\u0026rdquo; from the \u0026ldquo;View\u0026rdquo; menu as shown in the screenshot below.  In the command palette, type git clone to filter the list of available commands. Click on the command Git:Clone (not the Recursive clone).  When prompted for the repository URL, copy and paste the text below. This is the SSH format for the GitHub repository, which uses an SSH key that has been loaded on the Windows host for you.  git@github.com:wookie-labs/iac-user-{{pod}}.git When prompted for a destination, choose the \u0026ldquo;Documents\u0026rdquo; folder and click Select Repository Location as shown below.  Once the repository has been cloned, you will be prompted (lower right corner of the vsCode window) to open the local directory where the repository has been cloned. Click Open. This prompt does not stay open indefinitely. If you miss the prompt, you will have to choose File \u0026ndash;\u0026gt; Open Folder\u0026hellip; from within vsCode and browse to your project folder to open it.  You might see the following dialog box asking if you want vsCode to trust the authors of the files in this directory. If you see this dialog box, click the checkbox to trust the authors of all files in the parent folder and then the blue button labeled Yes, I trust the authors. Do not be concerned if you do not see this prompt.\nInstall Terraform extension The Terraform extension for vsCode provides conveniences that will make writing code easier and less prone to errors. Some benefits:\n syntax highlighting for .tf and .tfvars files closes curly braces and quotation marks completion of resource names, data source names, and attribute names for initialized providers  In this section you will verify the presence of the extension or install it if missing.\nSteps:\n In vsCode, click on the extensions icon as shown in the image below. The extensions view will show both installed and popular extensions. If the HashiCorp Terraform extension appears under \u0026ldquo;installed\u0026rdquo; extensions, you are done. Confirm that it is the HashiCorp extension and not an extension from Microsoft or other third party.  If the HashiCorp Terraform extension is not installed (as shown in the image above), use the \u0026ldquo;search extensions in marketplace\u0026rdquo; text box to search for \u0026ldquo;terraform\u0026rdquo; as shown in the image below. There are two extensions shown in the image below. Click the word Install next to the Terraform extension authored by HashiCorp and not any other extensions. It will take a few seconds to install. Clear the search box and confirm that the extension shows up in the \u0026ldquo;installed\u0026rdquo; group.  Open the terminal You will execute all of the command line commands for this lab from the terminal built into vsCode. vsCode supports multiple terminal types:\n PowerShell Command Prompt (traditional Windows command line) Git Bash (Mac or Linux style command line)  Steps:\n In vsCode, from the Terminal menu choose New Terminal if the terminal is not already open. This will open a PowerShell command terminal. If you are comfortable using PowerShell syntax, you can skip the next step. Open a new terminal as shown in the diagram below. You can choose from PowerShell, Command Prompt, and Git Bash. Command syntax for all three will be provided throughout this lab guide so you can select the option that makes you comfortable.  Congratulations! You have successfully prepared the Visual Studio Code IDE for use with this lab. Your vsCode window should look something like the image below (click on the image to magnify).\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/remote_cli/",
	"title": "Terraform remote CLI",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Remote CLI In this chapter, you will learn how to start using Terraform Cloud to execute the Terraform configuration specified in your local directory. Before proceeding, make sure you have completed all of the previous steps in this lab and that your local terraform.tfstate file contains your NTP policies. There was a checkpoint at the end of previous section of this lab. Make sure your configuration is similar (it does not have to be identical).\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/core_concepts/",
	"title": "Core Concepts",
	"tags": [],
	"description": "",
	"content": "Configuration Files When managing infrastructure with Terraform, all configuration is written into documents called Configuration files using the Terraform Language, which is Terraform\u0026rsquo;s primary user interface. Terraformâ€™s configuration language is declarative, meaning that it describes the desired end-state for your infrastructure, in contrast to procedural programming languages that require step-by-step instructions to perform tasks (more on this later).\nTerraform language is a rich language designed to be relatively easy for humans to read and write. The constructs in the Terraform language can also be expressed in JSON syntax, which is harder for humans to read and edit but easier to generate and parse programmatically. Code in the Terraform language is stored in plain text files with the .tf file extension while files written in the JSON-based variant of the language are named with .tf.json.\nTerraform language is built upon a broadly used syntax called Hashicorp Configuration Language (HCL), which is commonly used in other HashiCorp products and applications. The full Terraform language documentation can be found here.\nBelow is an example code snippet for creating an NTP policy in Cisco Intersight (the contents of this code will be explained thoroughly during the lab sections of this guide).\nresource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;east_coast\u0026#34; description = \u0026#34;IaC lab NTP policy for east coast\u0026#34; enabled = true ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } Directories and Modules A module is a collection of .tf and/or .tf.json files kept together in a directory.\nA Terraform module only consists of the top-level configuration files in a directory; nested directories are treated as completely separate modules, and are not automatically included in the configuration. The place where Terraform begins evaluating a configuration is referred to as the root module (or Workspace in Terraform Cloud and Terraform Enterprise).\nTerraform evaluates all of the configuration files in a module, effectively treating the entire module as a single document. Separating various configuration blocks into different files is purely for the convenience of readers and maintainers, and has no effect on the module\u0026rsquo;s behavior.\nA Terraform module can also use module blocks to explicitly include other modules into the configuration. These child modules can come from local directories (nested in the parent module\u0026rsquo;s directory, or anywhere else on disk), or from external sources like the Terraform Registry.\nState Terraform must store state about your managed infrastructure and configuration. This state is used by Terraform to map real world resources to your configuration, keep track of metadata, and to improve performance for large infrastructures.\nState is stored by default in a local file named terraform.tfstate, but it can also be stored remotely, which works better in a team environment. Terraform uses this local state to create plans and make changes to your infrastructure. Prior to any operation, Terraform does a refresh to update the state with the real infrastructure.\nThe primary purpose of Terraform state is to store bindings between objects in a remote system and resource instances declared in your configuration. When Terraform creates a remote object in response to a change of configuration, it will record the identity of that remote object against a particular resource instance, and then potentially update or delete that object in response to future configuration changes.\nState mapping is a major differentiator for how Terraform approaches configuration management. It allows configuration to be written in any order vs strictly adhering to a procedural order. All dependencies within a configuration document are automatically determined via state modelling. The Terraform language additionally allows for users to define explicit dependency definitions as well.\nWithout state, Terraform has no way to identify the real resources it created during previous runs. Thus, when multiple people are collaborating on shared infrastructure, it\u0026rsquo;s important to store state in a shared location, like a free Terraform Cloud organization.\nTerraform Binary (Terraform OSS) Terraform\u0026rsquo;s core capabilities comes from an open source distributable referred to as Terraform Open Source Software (OSS). Terraform OSS is written in Go and built as a standalone executable supported across many different platform architectures. Users would download and install the appropriate package for their operating system and system architecture. The most recent version of Terraform OSS can be downloaded here. You will not need to install Terraform for this lab as you will be provided with a Windows desktop that already has Terraform installed.\nStarting with the 1.x release of Terraform, the tool now supports upgrade compatibility within a major release. This means you can start with Terraform 1.0 and upgrade to the latest 1.x release without requiring any configuration changes.\nBecause Terraform is packaged as a standalone executable, there are no additional system dependencies required to run it on a supported platform. If you would like to quickly test using Terraform on your local machine simply download the latest version for your supported operating system using the link mentioned above and run the following command:\nterraform --version Providers If you install Terraform OSS and begin playing around with it, you will quickly realize there isn\u0026rsquo;t much you can do with the executable alone. This is because Terraform by design, decouples its core capabilities from its infrasctructure plugins called Providers. A provider plugin is responsible for understanding API interactions with some kind of service and exposing resources based on that API. In order to manage ANY infrastructure with Terraform, a provider is required.\nTerraform providers are generally tied to a specific infrastructure provider, which might be an infrastructure as a service (IaaS) provider (like AWS, GCP, Microsoft Azure, OpenStack), a platform as a service (PaaS) provider (like Heroku), a software as a service (SaaS) provider (like Terraform Cloud, Cisco Intersight, DNSimple, Cloudflare), or an on-premise infrastructure solution (like Cisco ACI, Cisco FMC, vCenter, Infoblox, F5, etc).\nFor the purposes of this lab, we will be primarily focused on using the Cisco Intersight provider . The full list of available providers can also be viewed on the Terraform Registry .\nMoving Forward Now that you understand some of the core concepts of Terraform, the next section will cover the types of content or blocks that you will use within your configuration code using the Terraform Language.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/tf_cloud/push_changes/",
	"title": "Push changes to GitHub",
	"tags": [],
	"description": "",
	"content": "In this section of the lab, you will push a small change to GitHub and confirm that Terraform Cloud automatically starts planning for the configuration change that you made.\nChange the configuration Make a small change to your configuration, commit that change, and push it to GitHub.\nSteps:\n In the ntp.tf file, change the line enabled = true to read enabled = false for the \u0026ldquo;east\u0026rdquo; NTP policy. Save your changes. Notice that the ntp.tf file has changed colors and has an \u0026ldquo;M\u0026rdquo; next to it to signify it has been modified since your last git commit. Also notice that there is now a \u0026ldquo;1\u0026rdquo; next to the Source Control icon in the left navigation of vsCode to signify that there is one file that has uncommitted changes to it.  Click on the Source Control icon in the left navigation of vsCode. Type a message such as disabled ntp east policy in the Message text box. Click the check mark above text box to commit changes. Click Yes when asked whether you would like to stage all your changes. If you attempt to commit changes when there are no changes staged, vsCode prompts you to commit all changes. It\u0026rsquo;s a convenient shortcut. Push your commit to GitHub. Remember that a push operation is performed by clicking the ellipses (...) and selecting Push. Use the bookmark in the Chrome browser to go to your GitHub repository and see that the last commit matches the changes you pushed.  Confirm Terraform Cloud run has started Now that your Terraform Cloud workspace is configured for VCS rather than Remote CLI, it should be aware of the changes you committed to GitHub.\nSteps:\n Use the bookmark in the Chrome browser to browse to Terraform Cloud. Log in if needed and click on your workspace. Click on the Runs tab. The \u0026ldquo;Current Run\u0026rdquo; should have the same name as your commit comment.  The run should be in either the \u0026ldquo;Planning\u0026rdquo; or \u0026ldquo;Cost estimated\u0026rdquo; state. Click on the run to see a summary.  The summary screen allows you to approve (Confirm and Apply) or reject (Discard Run) the plan. Much like the tf apply command you used in the early portions of this lab, this plan allows you to see the details of the proposed changes. Click on Plan finished to expand that section. Click the carrot (\u0026gt;) next to intersight_ntp_policy.east to see exactly what will be changed in that resource.  When you were applying configurations from the commandline, you had to type \u0026ldquo;yes\u0026rdquo; to approve the changes. In Terraform Cloud, you will click a button. Scroll down and click Confirm and Apply. An input box will appear. You can add a comment if you like or leave it blank. Click Confirm Plan.  The configuration will be applied by Terraform Cloud.\nFind your outputs When you were applying configurations from the command line, the outputs you specified would appear on the screen at the end of the run. In this section you will located those outputs in Terraform Cloud. Wait until the current run is complete before attempting this section.\nSteps:\n In Terraform Cloud, click on the Overview tab as shown in the image below. Below the overview of the latest run you will see two tabs. Click on the Outputs tab as shown in the image below.  You can also find the outputs from a previous run by clicking on that run in the Runs tab and expanding the section labeled \u0026ldquo;Apply finished\u0026rdquo;.\nCongratulations! You pushed a small configuration change to GitHub and how Terraform Cloud automatically started planning for those changes without your intervention. You approved that plan and watched it complete.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/tf_cloud/",
	"title": "GitHub + Terraform Cloud",
	"tags": [],
	"description": "",
	"content": "Chapter 5 GitHub + Terraform Cloud So far in this lab you have learned how to build a basic configuration in HCL and how to apply that configuration using both a locally-installed copy of Terraform OSS and Terraform Cloud in Remote CLI mode. With Terraform OSS, state was stored locally and with Remote CLI mode it was stored in the cloud. In both scenarios, however, the configuration files were stored on your local machine. This means there is no backup for your configuration. It also makes it very difficult to collaborate with a team, track the history of your changes, or institute an approval process for changes.\nIn this chapter, you will complete the journey to the cloud using git and GitHub as version control tools that facilitate more formal processes and teamwork.\nIt is important that you understand the differences between git and GitHub. Git is a very powerful and free version control system that allows for checkpoints or snapshots (called \u0026ldquo;commits\u0026rdquo; in git), branching, workflows, and rollbacks. GitHub is an online hosting site for version controlled projects using git. A developer will use git to track their code changes, but when the developer wants to collaborate with others, s/he \u0026ldquo;push\u0026rdquo; the code and its commits to GitHub. In this lab, you\u0026rsquo;ll be using vsCode to perform the git and GitHub operations, so the delineation between the two might seem blurry.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/remote_cli/configure_tfcloud/",
	"title": "Move variables to the cloud",
	"tags": [],
	"description": "",
	"content": "Although you have configured Terraform to use Terraform Cloud to execute your configuration, your credentials are still stored as environment variables on your Windows host. Terraform Cloud cannot access those environment variables. In this portion of the lab, you will save your credentials as variables within Terraform Cloud and update your configuration files to use those new variables.\nConfigure variables in Terraform Cloud You must add your credentials to Terraform Cloud. You will add them as Terraform variables and not environment variables because Terraform Cloud does not currently handle multi-line environment variables, and your API secret is long.\nSteps:\n Browse to https://app.terraform.io. There is also a bookmark in the Chrome browser for Terraform Cloud. Click on your workspace and then click on the Variables tab as shown in the image below. Notice that under the \u0026ldquo;Terraform Variables\u0026rdquo; heading, there is a statement that these variables are set using a terraform.tfvars file. Remember that that file has the highest precedence among Terraform variable files as discussed in an earlier section. Click on Add variable as shown below. Be sure to click the button under the \u0026ldquo;Terraform Variables\u0026rdquo; section and not the \u0026ldquo;Environment Variables\u0026rdquo; section of this page.  It is important to note what you are doing here, as many people get confused by the fact that there is a \u0026ldquo;Description\u0026rdquo; field. You are not defining a variable. You are defining a variable\u0026rsquo;s value. This step serves the same purpose as any line in the myvalues.auto.tfvars file, which follows the format Key=Value to define variable values. Remember that any variable whose value you declare in Terraform Cloud must be defined in your configuration. You actually defined \u0026ldquo;intersight_api_key\u0026rdquo; and \u0026ldquo;intersight_api_secret\u0026rdquo; when you created the variables.tf file in an earlier section of this lab. The guide stated that you would use those variables at a later time. That time is now! Variables must be defined (such as in variables.tf) and then a value can be assigned to them (such as in *.auto.tfvars).\nEnter intersight_api_key as the variable \u0026ldquo;Key\u0026rdquo; and the actual API key as the variable \u0026ldquo;Value\u0026rdquo;. If you\u0026rsquo;ve misplaced your API key, you can retrieve it from Intersight or copy it from the text box below. Click Save variable.  {{ api_key }} Repeat this process for the API secret. Click Add variable in Terraform Cloud. Enter intersight_api_secret as the variable \u0026ldquo;Key\u0026rdquo; and the entire contents of your SecretKey.txt file as the variable \u0026ldquo;Value\u0026rdquo;. Be sure to copy the entire file including the \u0026ldquo;BEGIN\u0026rdquo; and \u0026ldquo;END\u0026rdquo; lines. Mark this variable as Sensitive as shown in the image below and click Save variable.  Your variables should now look similar to the image below but with a different value for \u0026ldquo;intersight_api_key\u0026rdquo;.\nUpdate provider configuration The Intersight provider for Terraform looks for provider-specific parameters in your environment variables if they are not specified in the \u0026ldquo;provider\u0026rdquo; block. You set all of those properties as environment variables earlier in the lab, and that is why you were able to leave the provider block empty as shown below. This must change so that Terraform knows where to find the API key and secret for the provider.\nprovider \u0026#34;intersight\u0026#34; {# Configuration options } In this section of the lab, you will update your configuration\u0026rsquo;s provider block with the locations of those properties (two will be variables and one will be hard coded).\nSteps:\n In vsCode, open the providers.tf file. Replace the provider block in that file with the following snippet. Do not modify the terraform block in that file. This code tells Terraform that the API key and secret are both specified as variables. Optionally you could also define the provider \u0026ldquo;endpoint\u0026rdquo; as a variable in Terraform Cloud if you choose. This set of instructions shows the endpoint hard coded to \u0026ldquo;intersight.com\u0026rdquo;. Save the providers.tf file.  provider \u0026#34;intersight\u0026#34; { apikey = var.intersight_api_key secretkey = var.intersight_api_secret endpoint = \u0026#34;intersight.com\u0026#34; } Remove your local environment variables This step is completely optional, but if you want to prove to yourself that Terraform is no longer using your local environment variables, the best way to do that is to delete them. You can paste one of the snippets below into the vsCode terminal to delete the environment variables you created earlier.\nPowerShell\nRemove-Item env:INTERSIGHT_API_KEY Remove-Item env:INTERSIGHT_SECRET_KEY Remove-Item env:INTERSIGHT_ENDPOINT_URL Windows cmd\nset INTERSIGHT_API_KEY= set INTERSIGHT_SECRET_KEY= set INTERSIGHT_ENDPOINT_URL= Mac/Linux bash\nunset INTERSIGHT_API_KEY unset INTERSIGHT_SECRET_KEY unset INTERSIGHT_ENDPOINT_URL Perform a remote run Terraform has been configured to run remotely and some variables have been defined in Terraform Cloud while others remain defined in your configuration files. Recall from a previous section that variable values are discovered in the order detailed below, effectively giving environment variables the lowest priority. The variables you defined above in Terraform Cloud have a higher priority than any of your configuration files. If a variable value is defined in two places, the file or location with the highest precedence will be the value applied to your configuration.\n environment variables named TF_VAR_\u0026lt;variable_name\u0026gt; the file named terraform.tfvars any file named *.auto.tfvars  In this section of the lab, you will verify your credentials are being sourced properly by Terraform and experiment with the order of precedence of variable files.\nSteps:\n From the vsCode terminal, execute the command tf apply. Notice the changes that Terraform indicates no changes will occur. This makes sense since you did not make any configuration changes other than moving your credentials to Terraform Cloud. A success on this step means you transferred your credentials properly. If you get any errors, check the two variables that you created in Terraform Cloud.  Notice that your state, your credentials, and the actual configuration operations are all being handled by Terraform Cloud. You are issuing the commands from the Windows host, but they are being fulfilled remotely. That is why this mode is called Remote CLI.\nAt this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. backend.tf terraform { backend \u0026#34;remote\u0026#34; { hostname = \u0026#34;app.terraform.io\u0026#34; organization = \u0026#34;Wookie-Labs\u0026#34; workspaces { name = \u0026#34;iac-user-{{pod}}\u0026#34; } } }   myvalues.auto.tfvars policy_name_prefix = \u0026#34;iac-lab\u0026#34; policy_description = \u0026#34;created by Terraform\u0026#34; east_timezone = \u0026#34;America/New_York\u0026#34; west_timezone = \u0026#34;America/Los_Angeles\u0026#34;   ntp.tf resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;west\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-west\u0026#34; description = var.policy_description enabled = true timezone = var.west_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }   outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid } output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; { apikey = var.intersight_api_key secretkey = var.intersight_api_secret endpoint = \u0026#34;intersight.com\u0026#34; }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{ pod }}\u0026#34; }   variables.tf variable \u0026#34;policy_name_prefix\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;policy_description\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;west_timezone\u0026#34; { description = \u0026#34;timezone used for west NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;intersight_api_secret\u0026#34; { type = string default = \u0026#34;\u0026#34; } variable \u0026#34;intersight_api_key\u0026#34; { type = string default = \u0026#34;\u0026#34; }   Congratulations! You have successfully replaced local credentials with values stored securely in the cloud. You learned that variables can be sourced from multiple locations. You also successfully ran Terraform commands in Remote CLI mode.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/open_source/ntp_policy/",
	"title": "Create an Intersight policy",
	"tags": [],
	"description": "",
	"content": "So far, you have only retrieved an existing item from Intersight. In this section, you will create a policy in the organization that you retrieved in the previous step. Terraform can create any policy that can be created by the Intersight API. You will focus on NTP policy as it has multiple parameters yet is self-contained.\nCreate an NTP policy in Intersight You will use the Terraform resource block to define a new policy. A resource block starts with the keyword \u0026ldquo;resource\u0026rdquo; and includes the resource type (\u0026ldquo;intersight_ntp_policy\u0026rdquo; in the snippet below) and the resource local name (\u0026ldquo;east\u0026rdquo; in the snippet below). The code between the curly braces are the configuration arguments for this resource. Example:\nresource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { INSERT_CONFIGURATION_ARGUMENTS_HERE } Now you will use that format to create an NTP policy.\nSteps:\n Create a new file in your project directory named ntp.tf. Search for NTP in the Intersight provider documentation in the Terraform registry. Notice the similarity between the example code in the documentation and the snippet below for the resource \u0026ldquo;intersight_ntp_policy\u0026rdquo;. The name, description, and organization have different values than the example. The biggest difference is the value for organization, which uses the data source you created earlier to point to your organization\u0026rsquo;s MOID. Make sure you understand where the value data.intersight_organization_organization.iac.results[0].moid for organization MOID comes from. Copy snippet below and paste it into your ntp.tf file. You can change the policy name, description, or even the list of NTP servers if you like. Run the tf apply command in the terminal and notice that Terraform enumerates all of the proposed changes with green + signs to indicate resources and parameters that will be added. Type \u0026ldquo;yes\u0026rdquo; to approve the changes.  resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;ntp-east\u0026#34; description = \u0026#34;IaC lab NTP policy for east location\u0026#34; enabled = true ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } You can verify that your NTP policy was created properly by locating it in the Intersight GUI. Browse to Configure \u0026ndash;\u0026gt; Policies in the Intersight left navigation and then click on the NTP policy you just created. Notice that the timezone is set to a surprising value because it was not defined by your configuration. Timezone is an optional parameter in the Intersight provider (and the Intersight API), but it is not an optional parameter in the Intersight GUI. This lab guide will show you how to fix that shortly.\nCreate more outputs You can confirm the timezone for the NTP policy without logging into Intersight. Instead, you can add additional outputs to your configuration.\nSteps:\n Add the code snippet below to your existing outputs.tf file. Remember that this code block could be added to any file in your project but it is best practice to keep your outputs together. Notice that these output values differ from the one you created for \u0026ldquo;organization\u0026rdquo; in that it doesn\u0026rsquo;t use the data keyword. In HCL, the properties of a resource are referenced as shown below. They do not use the data keyword because they are not data sources. From the vsCode terminal, run tf apply and confirm that you see the MOID and timezone of your NTP policy.  output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone } Set timezone manually When deploying resources through IaC, you should expect that all changes to those resources should also be deployed through IaC. Manual changes should not be made to those resources. In this section, you will explore what happens when making manual changes to the NTP policy you created.\nSteps:\n Locate your NTP policy in the Intersight GUI. Edit the policy to set the timezone to the east coast (America/New_York). You may also change the name, description, or even delete one of the NTP servers from the list if you choose. From the vsCode terminal, run the command tf apply. Notice that Terraform details the changes that will take place with a yellow tilde (~), indicating that this policy will be altered in place rather than deleted and recreated. Type \u0026ldquo;yes\u0026rdquo; to confirm those changes. Refresh the page in the Intersight GUI showing your NTP policy and notice that it has been changed back to the original configuration. From the vsCode terminal, run the command tf apply again. Notice this time Terraform indicates that no changes are necessary because now the environment perfectly matches your specified configuration.  Fix the timezone in HCL The proper way to make configuration changes to elements created by Terraform is in your HCL.\nSteps:\n Go back to the provider documentation for NTP and determine how to add the correct timezone for your location to the resource definition for NTP. Note that timezone is a property just like name and description and should be defined similarly using the property = \u0026ldquo;value\u0026rdquo; syntax. Keep in mind that HCL is very flexible and the order in which parameters are defined in a resource block does not matter. Save the changes to ntp.tf and run the tf apply command again in the terminal. Notice that Terraform details the changes that will take place with a yellow tilde (~), indicating that this policy will be altered in place rather than deleted and recreated. Type \u0026ldquo;yes\u0026rdquo; to confirm that Terraform should execute the changes. Confirm in Intersight that the NTP policy timezone has been updated.  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. ntp.tf resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;ntp-east\u0026#34; description = \u0026#34;IaC lab NTP policy for east location\u0026#34; enabled = true timezone = \u0026#34;America/New_York\u0026#34; ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }   outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid } output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; }   Congratulations! You have deployed your first resource through Terraform and then updated it. You also learned that resources deployed through Terraform should be managed entirely through Terraform. You witnessed an important feature of good IaC tools: idempotence. An operation is idempotent if it can be executed multiple times without changing the environment. When you performed tf apply twice and the second run didn\u0026rsquo;t affect Intersight, you witnessed idempotence. Idempotence implies that applying a known good configuration is safe because it will not affect the environment if it is already configured properly.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/basics/api_keys/",
	"title": "Obtain API keys",
	"tags": [],
	"description": "",
	"content": "Terraform will use an API key to authenticate to Intersight on your behalf. In this section of the lab, you will generate an API key in Intersight and set environment variables on the Windows host so that Terraform can use that API key.\nObtain Intersight API keys You must generate an API key for your user account. Perform the following from within the Intersight user interface.\nSteps:\n From the top navigation bar, select the Settings icon and choose the Settings option from the dropdown. Account Administrators will see more items in this dropdown list, but your privileges only allow you to see \u0026ldquo;Settings\u0026rdquo;.  From the left side of the Intersight user interface, select API Keys.  Click the Generate API Key button.  In the dialog box, give the API key a brief description and select \u0026ldquo;version 2\u0026rdquo; schema for the \u0026ldquo;API Key Purpose\u0026rdquo; as shown in the image below. You can use any text for the description.  Click the Generate button. You will be presented with a dialog box showing the API Key ID and Secret Key. You will be able to view the API Key ID at any time in the Intersight GUI, but the Secret Key will only be shown to you once. Click the button to save the Secret Key to a file as shown in the image below. It will be saved to the Windows 10 \u0026ldquo;Downloads\u0026rdquo; folder as \u0026ldquo;SecretKey.txt\u0026rdquo;. For the purposes of this lab, you will leave the file in that location. In a production environment you must be much more careful with your API key and secret.   Copy the API Key ID to the clipboard using the icon to the right of the API Key ID and paste it here. You wouldn\u0026rsquo;t normally paste your API key into a lab guide, but doing so will simplify some of the copy/paste operations you have to do later in this lab. SomethingApply\n  Click Close to dismiss the API key dialog box. You should see your newly created API key in the table in Intersight.\n  You have generated an API key for Intersight that is tied to your user account. The next step is to save that as a set of environment variables.\nSet environment variables Terraform will look for credentials in the following locations:\n Terraform configuration files Terraform runtime variables environment variables  In this lab, you will configure environment variables for your credentials. Perform the following steps from the vsCode terminal.\nSteps:\n Copy the appropriate set of commands from below. If you pasted your API key into the lab guide in the previous section and clicked Apply, then your API key should appear correctly in the snippets below. If you\u0026rsquo;ve misplaced the key, you can always copy it again from Intersight (only the secret cannot be viewed again in Intersight). Paste the snippet with the correct API key into the terminal in vsCode to execute these commands.  PowerShell\n$env:INTERSIGHT_API_KEY=\u0026#34;{{ api_key }}\u0026#34; $env:INTERSIGHT_SECRET_KEY=\u0026#34;$HOME\\Downloads\\SecretKey.txt\u0026#34; $env:INTERSIGHT_ENDPOINT_URL=\u0026#34;intersight.com\u0026#34; Windows cmd\nset INTERSIGHT_API_KEY={{ api_key }} set INTERSIGHT_SECRET_KEY=%userprofile%\\Downloads\\SecretKey.txt set INTERSIGHT_ENDPOINT_URL=intersight.com Mac/Linux bash\nexport INTERSIGHT_API_KEY={{ api_key }} export INTERSIGHT_SECRET_KEY=~/Downloads/SecretKey.txt export INTERSIGHT_ENDPOINT_URL=intersight.com You have now set the API key and the location of the secret as an environment variables.\nVerify environment variables This section of the guide provides the command required to display the environment variables you configured in the previous section. This serves the purpose of visually confirming that the previous commands worked (sanity check). There is no need to inspect every character of the key.\nPowerShell\nGet-ChildItem env: | ? {$_.Name -match \u0026#39;INTERSIGHT\u0026#39;} Windows cmd\nset INTERSIGHT Mac/Linux bash\nprintenv | grep INTERSIGHT Congratulations! You have successfully obtained API credentials from Intersight and saved those credentials as environment variables in your IDE. When you execute Terraform commands in future sections of the lab, Terraform will use these environment variable values for authentication.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/open_source/destroy/",
	"title": "Destroy operations",
	"tags": [],
	"description": "",
	"content": "One of the advantages of Terraform and other IaC tools is its ability to remove the infastructure that it created. Some tools, like Ansible, require the administrator to write the delete plan, which is often just as complex as the create plan. Terraform uses the state file and the configuration you\u0026rsquo;ve already written to delete resources that it created, and it knows how to do it in the correct sequence.\nDelete the infrastructure In this section of the lab, you will delete and then recreate your NTP policy and prove that the recreated policy is new even though it is configured identically.\nSteps:\n In the Intersight GUI, browse to the NTP policy you created. Notice that the URL follows the format https://intersight.com/an/policy/policies/ntp-policy/613a2a4a6275722d300c7646/view. The sequence of numbers and characters in the URL is the MOID of that policy and uniquely identifies that object within the Intersight account. Make note of that MOID. The MOID should also appear in the vsCode terminal at the end of your last Terraform run since the NTP policy MOID is one of the outputs you defined. From the vsCode terminal, run the command tf destroy. Note the red minus (-) symbols indicating the resources and properties that Terraform will delete. Note that Terraform will not delete your organization but will simply remove the organization as a data source in your state file. Resources are deleted from Intersight and data sources are not. Type \u0026ldquo;yes\u0026rdquo; to proceed. Check the Intersight GUI and notice that the NTP policy has been removed. Check the Terraform state file and notice that the NTP policy is absent. From the vsCode terminal, run the command tf apply and type \u0026ldquo;yes\u0026rdquo; to confirm. Notice the MOID displayed in the console is different than the MOID of the policy that you had created (and deleted) earlier. Even though this policy has the same name and is configured identically to the former policy, it is a new policy.  Congratulations! You learned that Terraform can remove all of the objects it created without having to write any additional code. You deleted a policy and then recreated an identical policy and proved that the two policies are different even though they are configured identically.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/configuration_files/",
	"title": "Configuration Blocks",
	"tags": [],
	"description": "",
	"content": "Resources Resources are the most important element in the Terraform language. Each resource block describes one or more infrastructure objects, such as an Intersight NTP policy, server profile, identity pool, AWS virtual network, compute instance, or high-level components such as DNS records. A resource block is also referred to as managed resource as Terraform is managing the configuration of that infrastructure object.\nA resource block in a .tf config file declares a resource of a given type e.g. (\u0026ldquo;intersight_ntp_policy\u0026rdquo;) with a given local name (\u0026ldquo;east\u0026rdquo;). The name is used to refer to this resource from elsewhere in the same Terraform module, but has no significance outside that module\u0026rsquo;s scope.\nMost of the configuration used within the body of a resource block are arguments that are specific to the selected resource type. The resource type\u0026rsquo;s documentation lists which arguments are available and how their values should be formatted. Let\u0026rsquo;s revisit the resource block example shown on the previous page:\nresource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;east_coast\u0026#34; description = \u0026#34;IaC lab NTP policy for east coast\u0026#34; enabled = true ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } In the code above, all of the configuration within the resource block are arguments related to the intersight_ntp_policy resource type. The documentation for this resource type including all supported arguments, value formats, and examples can be found here.\nData Sources Unlike resources, data sources do not create or manage infrastructure. Instead, they return information about some kind of external object in the form of readable attributes. This allows a Terraform configuration to make use of information defined outside of Terraform, or defined by a separate Terraform configuration. A data source is accessed via a special kind of resource known as a data resource, declared using a data block as shown below:\ndata \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; } Much like resources, data sources are given a type e.g. (\u0026ldquo;intersight_organization_organization\u0026rdquo;) and a local name (\u0026ldquo;iac\u0026rdquo;). When distinguishing from resources mentioned previously, both kinds of resources take arguments and export attributes for use in configuration, but while managed resources cause Terraform to create, update, and delete infrastructure objects, data resources cause Terraform only to read objects.\nIn the Getting Started \u0026gt; Basic validation section you will examine how this data source and associated attributes are stored in state and can be referenced in other parts of your configuration code.\nInput Variables In general-purpose programming, a variable is a symbolic name associated with a value. In the Terraform language, variables must be explicitly declared and typed before being used. Within a variable block, the following arguments are supported:\n default - A default value which then makes the variable optional. type - Specifies what value types are accepted for the variable. Review the full list of supported types here description - Specifies the input variable\u0026rsquo;s documentation. validation - A block to define validation rules, usually in addition to type constraints. sensitive - Limits Terraform UI output when the variable is used in configuration.  Similar to resources and data sources, a variable block must be given a unique local name. To declare a new variable simply include a variable block similar to the one below:\nvariable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } In the variable block above the variable name is east_timezone, the type is string, the default value is \u0026ldquo;America/Chicago\u0026rdquo;, and a description is provided as reference for anyone reviewing the code. You can now reference this variable in other configuration blocks using the var.\u0026lt;NAME\u0026gt; syntax as shown in the timezone attribute of the resource block below:\nresource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;east_coast\u0026#34; description = \u0026#34;IaC lab NTP policy for east coast\u0026#34; enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } String Interpolation Embedded within strings in Terraform, whether you\u0026rsquo;re using the Terraform syntax or JSON syntax, you can interpolate other values. These interpolations are wrapped in ${}, such as \u0026ldquo;${var.policy_name_prefix}-ntp-east\u0026rdquo; as shown in the resource block below:\nresource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } Terraform knows to replace ${var.policy_name_prefix} with whatever its current value is. For example, if var.policy_name_prefix is set to \u0026ldquo;iac-lab\u0026rdquo; then the name attribute would fully resolve to \u0026ldquo;iac-lab-ntp-east\u0026rdquo;.\nString interpolation is only required when combining terraform language code, such as a variable or a resource attribute value, with string values. If you are only referencing a variable or resource attribute value alone then there is not need to interpolate as shown in the description, timezone, and organization.moid attributes of the code block above.\nOutputs Output values are like the return values of a Terraform module, and have several uses:\n A child module can use outputs to expose a subset of its resource attributes to a parent module. A root module can use outputs to print certain values in the CLI output after running terraform apply. When using remote state, root module outputs can be accessed by other configurations via a terraform_remote_state data source.  Resource instances managed by Terraform each export attributes whose values can be used elsewhere in configuration. Output values are a way to expose some of that information to the user of your module. Output blocks simply contain a name and a value as shown below:\noutput \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } In the above output, the value is set to one of the attributes of the intersight_ntp_policy resource named \u0026ldquo;east\u0026rdquo;. It is always best to review the provider documentation to know what attributes are available for a given resource.\nDependency Mapping Now that the various types of configuration blocks have been more thoroughly explained, let\u0026rsquo;s review once again the following configuration code:\noutput \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;east_coast\u0026#34; description = \u0026#34;IaC lab NTP policy for east coast\u0026#34; enabled = true ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; } One may think when looking at the code above that applying this configuration would result in errors because of the written procedural order. However, when Terraform compiles a terraform document from the configuration files within a working directory, it models the proposed configuration into a formatted state. During this state modelling, Terraform automatically figures out and documents dependencies.\nIn the code example above, the data block will execute first as it has no dependencies, followed by the resource block which contains a reference to an attribute of the data block, and lastly the output block due to its dependency on an attribute of the resource block.\nMoving Forward Now that you know more about how Terraform configuration files are written, let\u0026rsquo;s take a deeper dive into how Terraform performs state management.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/tf_cloud/rollback/",
	"title": "Rollback",
	"tags": [],
	"description": "",
	"content": "Sometimes mistakes are made. In the previous section of the lab, you committed a change to disable an NTP policy. If this had been a mistake, it would be trivial for you to change the configuration back to enabled=true and commit the change. If there had been dozens of changes, it would be more difficult to manually undo each change. In this section you will learn to rollback the previous commit using git revert through vsCode.\nInstall git extension for vsCode There are git methods like branching and amending previous commits that are beyond the scope of this lab. In this lab, you have used vsCode to perform git operations for you but every git command in this lab could be done at the command line:\n git clone git add [filename] git commit -M \u0026ldquo;initial commit\u0026rdquo; git push  You will install a popular vsCode extension for git to perform rollback. This process is similar to the installation of the Terraform extension for vsCode that you did earlier in the lab.\nSteps:\n Click on the Extensions menu in the left navigation of vsCode as shown in the image below. Type gitlens in the search box. Click Install for the GitLens extension. You should install the extension that has more than 10 million downloads and not the GitLens \u0026ldquo;insiders\u0026rdquo; extension.  Rollback Steps:\n Click the Source Control menu in the left navigation of vsCode as shown in the image below. Expand the \u0026ldquo;Commits\u0026rdquo; section of the display as shown in the image below. This section and the sections below it were all added as part of the installation of the GitLens extension in the previous section of this lab. You can use this section to view the history of your commits, including the most recent commit to disable one of the NTP policies.  Right-click on the most recent commit and choose Revert Commit\u0026hellip; as shown in the image below.  Confirm the revert operation by clicking Revert in the \u0026ldquo;Confirm\u0026rdquo; dropdown as shown in the image below. This creates a new commit on the Windows host, but this new commit has not been pushed to GitHub yet.  Click the ellipses (...) next to \u0026ldquo;Source Control\u0026rdquo; and select Push as shown in the image below.  Within a few seconds, you can check your GitHub repository and see the comment next to ntp.tf has changed to show that it has been reverted. Browse to Terraform Cloud and verify that a new run is being planned with a name indicating that it is reverting your previous commit. As you have done several times already in this lab, click on the run, click Confirm and Apply and then click Confirm Plan. The run to revert the disabling of the NTP policy is now underway.  Congratulations! You have successfully reverted a commit in git and GitHub. This illustrates how an unintended infrastructure change can be reverted.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/open_source/variables/",
	"title": "Employ variables",
	"tags": [],
	"description": "",
	"content": "It is a good idea to start implementing variables before the configuration gets too large. Variables are helpful when a value is repeated in multiple places in your configuration but also when you don\u0026rsquo;t know the value at the time of writing the HCL (it will be supplied later by the person using the code).\nCreate variable definitions In this section of the lab, you will define the variables that will be used for the remainder of the lab. Each variable is defined by the keyword variable and is given a name. Defining the variable\u0026rsquo;s description, data type, and default value are all optional.\n The variable name is inline with the variable keyword. For example, the first variable defined in the snippet below is named \u0026ldquo;policy_name_prefix\u0026rdquo;. The description property provides an explanation of the purpose of the variable. This field is not used by Terraform to make any decisions. The data type of the variable is optional, but it is highly recommended to define it to avoid having the type interpreted incorrectly by Terraform. Consult the documentation for a complete description of the different data types. A variable becomes optional when a default is specified. When defining a secret such as a password, the variable should be marked as sensitive by adding sensitive = true to the variable definition block. By default, variables are not sensitive. Sensitive variable values will not be logged or echoed to the screen, but will be stored in plain text in the Terraform state file. The state file has to contain the values for sensitive variables so that Terraform can determine if their values have changed for subsequent runs.  Steps:\n Create a new file named variables.tf and paste the code snippet below into that file. This code defines many variables, but two of them will not be used in this chapter of the lab guide. The \u0026ldquo;intersight_api_secret\u0026rdquo; and \u0026ldquo;intersight_api_key\u0026rdquo; will be used in a later chapter, but it is easier to define them now while you are editing this file.  variable \u0026#34;policy_name_prefix\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;policy_description\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;west_timezone\u0026#34; { description = \u0026#34;timezone used for west NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;intersight_api_secret\u0026#34; { type = string default = \u0026#34;\u0026#34; } variable \u0026#34;intersight_api_key\u0026#34; { type = string default = \u0026#34;\u0026#34; } Supply values for variables The step above defined the variables but did not supply values for those variables. Terraform automatically looks for variable values in the following locations and order. The order is important as a variable value can be overridden if it is defined in two or more locations.\n environment variables named TF_VAR_\u0026lt;variable_name\u0026gt; the file named terraform.tfvars any file named *.auto.tfvars  Other variable files can be specified at run time. For documentation of variable file precendence, read this. For this lab, you will put all variable values in a single file. You will not use terraform.tfvars for this purpose at this time. Later in the lab, you will see that Terraform Cloud uses that filename for variables defined within Terraform Cloud.\nSteps:\n Create a file named myvalues.auto.tfvars. Add the code below to this file. Note that the last line is optional since there is a default value specified in the variable definition for \u0026ldquo;east_timezone\u0026rdquo;. Feel free to experiment with including and excluding this line.  policy_name_prefix = \u0026#34;iac-lab\u0026#34; policy_description = \u0026#34;created by Terraform\u0026#34; east_timezone = \u0026#34;America/New_York\u0026#34; west_timezone = \u0026#34;America/Los_Angeles\u0026#34; Use variables in your code The steps above defined variables and their values, but you have yet to actually use those values in your Terraform configuration. In this section, you will use three of these variables.\nSteps:\n Run tf apply to ensure the NTP policy has been created. Replace the contents of ntp.tf with the code below. Run tf apply. Confirm in Intersight that the name, description, and timezone for the NTP policy have all changed.  resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } In the code above, var.policy_description and var.east_timezone are simple substitutions for the hardcoded values that were in the Terraform configuration before. This adds the flexibility to define these values at runtime and to use the same description for a handful of policies that might be created. The policy name variable is used differently. The syntax ${} tells Terraform to insert a variable value into the string so that \u0026quot;${var.policy_name_prefix}-ntp-east\u0026quot; should actually generate the policy name \u0026ldquo;iac-lab-ntp-east\u0026rdquo;.\nAt this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. myvalues.auto.tfvars policy_name_prefix = \u0026#34;iac-lab\u0026#34; policy_description = \u0026#34;created by Terraform\u0026#34; east_timezone = \u0026#34;America/New_York\u0026#34; west_timezone = \u0026#34;America/Los_Angeles\u0026#34;   ntp.tf resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }   outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid } output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; }   variables.tf variable \u0026#34;policy_name_prefix\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;policy_description\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;west_timezone\u0026#34; { description = \u0026#34;timezone used for west NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;intersight_api_secret\u0026#34; { type = string default = \u0026#34;\u0026#34; } variable \u0026#34;intersight_api_key\u0026#34; { type = string default = \u0026#34;\u0026#34; }   Congratulations! You have defined several variables, specified values for some of those variables, and applied a configuration with those new variable values. Feel free to change those values and run the configuration again to see what happens.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/basics/create_alias/",
	"title": "Create alias",
	"tags": [],
	"description": "",
	"content": "Most developers tire of typing the command terraform repeatedly and prefer to abbreviate that as tf. In this section of the lab, you will create an alias on the Windows 10 host to do the same.\nSteps:\n Choose the appropriate syntax below and paste that command into the vsCode terminal. Enter the command tf -version into the vsCode terminal. If you receive a message displaying the running Terraform version, you have successfully created the alias. You can disregard any messages you might see about your Terraform version being out of date.  PowerShell\nNew-Alias -Name tf -Value terraform Windows cmd\ndoskey tf=terraform $* Mac/Linux bash\nalias tf=terraform Congratulations! You have successfully created an alias for the terraform command and can now use tf instead.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/state_management/",
	"title": "State Management",
	"tags": [],
	"description": "",
	"content": "As mentioned previously, Terraform\u0026rsquo;s ability to store any infrastructure\u0026rsquo;s configuration into a consistent state format is a key differentiator to how this IaC toolset works. Because state is so important it merits it\u0026rsquo;s own section to explain further.\nPurpose of Terraform State Terraform uses state to document the expected configuration of managed infrastructure. You may wonder if Terraform could work without state by simply re-inspecting the managed resources prior to applying any configuration changes. While it might seem possible in some cases, the reality is your simply shifting the complexity from one place (state) to another (the replacement logic). The following subsections help further explain the value of state.\nResource Mapping Terraform requires some sort of database to map Terraform config to the real world. When you have a resource \u0026ldquo;intersight_ntp_policy\u0026rdquo; \u0026ldquo;east\u0026rdquo; in your configuration, Terraform uses this map to know that Moid 6138396d6972652d3029a3a8 is represented by that resource.\nTerraform expects that each remote object is bound to only one resource instance, which is normally guaranteed by Terraform being responsible for creating the objects and recording their identities in the state. If you instead import objects that were created outside of Terraform, you\u0026rsquo;ll need to check yourself that each distinct object is imported to only one resource instance.\nMetadata Alongside the mappings between resources and remote objects, Terraform must also track metadata such as resource dependencies.\nTerraform typically uses the configuration to determine dependency order. However, when you delete a resource from a Terraform configuration, Terraform must know how to delete that resource. Terraform can see that a mapping exists for a resource not in your configuration and plan to destroy. However, since the configuration no longer exists, the order cannot be determined from the configuration alone.\nTo ensure correct operation, Terraform retains a copy of the most recent set of dependencies within the state. Now Terraform can still determine the correct order for destruction from the state when you delete one or more items from the configuration.\nPerformance In addition to basic mapping, Terraform stores a cache of the attribute values for all resources in the state. This is the most optional feature of Terraform state and is done only as a performance improvement.\nWhen running a terraform plan, Terraform must know the current state of resources in order to effectively determine the changes that it needs to make to reach your desired configuration.\nFor small infrastructures, Terraform can query your providers and sync the latest attributes from all your resources. This is the default behavior of Terraform: for every plan and apply, Terraform will sync all resources in your state.\nFor larger infrastructures, querying every resource is too slow. Many cloud providers do not provide APIs to query multiple resources at once, and the round trip time for each resource is hundreds of milliseconds. On top of this, cloud providers almost always have API rate limiting so Terraform can only request a certain number of resources in a period of time. Larger users of Terraform make heavy use of the -refresh=false flag as well as the -target flag in order to work around this. In these scenarios, the cached state is treated as the record of truth.\nSyncing In the default configuration, Terraform stores the state in a file in the current working directory where Terraform was run. This is okay for getting started, but when using Terraform in a team it is important for everyone to be working with the same state so that operations will be applied to the same remote objects.\n Remote state is the recommended solution to this problem. With a fully-featured state backend, Terraform can use remote locking as a measure to avoid two or more different users accidentally running Terraform at the same time, and thus ensure that each Terraform run begins with the most recent updated state.\nFormat Now that you understand the value of state, let\u0026rsquo;s review what an actual state file looks like. State snapshots are stored in JSON format and new Terraform versions are generally backward compatible with state snapshots produced by earlier versions. While the format of the state files are just JSON, direct file editing of the state is discouraged. Terraform provides the terraform state command to perform basic modifications of the state using the CLI.\nRevisiting the previous configuration example, let\u0026rsquo;s say we apply the following configuration (Terraform actions such as plan, apply and destroy will be covered in the next section)\noutput \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;east_coast\u0026#34; description = \u0026#34;IaC lab NTP policy for east coast\u0026#34; enabled = true ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; } Assuming our provider authentication has been configured properly (you will go through this in the lab) your state file should resemble the following:\nSome of the output below has been removed for readability reasons\n { \u0026#34;version\u0026#34;: 4, \u0026#34;terraform_version\u0026#34;: \u0026#34;1.0.6\u0026#34;, \u0026#34;serial\u0026#34;: 2, \u0026#34;lineage\u0026#34;: \u0026#34;e98beb19-8d41-e8d1-36b2-26aedcb09c90\u0026#34;, \u0026#34;outputs\u0026#34;: { \u0026#34;ntp_east_moid\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;mode\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_organization_organization\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;iac\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;id\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, . . . \u0026#34;results\u0026#34;: [ { . . . \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;IaC_User_{{ pod }}\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, } ], }, \u0026#34;sensitive_attributes\u0026#34;: [] } ] }, { \u0026#34;mode\u0026#34;: \u0026#34;managed\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_ntp_policy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;east\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;id\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;mod_time\u0026#34;: \u0026#34;2021-09-24 14:31:40.342 +0000 UTC\u0026#34;, \u0026#34;moid\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;east_coast\u0026#34;, \u0026#34;ntp_servers\u0026#34;: [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ], \u0026#34;object_type\u0026#34;: \u0026#34;ntp.Policy\u0026#34;, \u0026#34;organization\u0026#34;: [ { \u0026#34;additional_properties\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;class_id\u0026#34;: \u0026#34;mo.MoRef\u0026#34;, \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;\u0026#34; } ], . . . \u0026#34;timezone\u0026#34;: \u0026#34;Pacific/Niue\u0026#34;, \u0026#34;version_context\u0026#34;: [] }, \u0026#34;sensitive_attributes\u0026#34;: [], \u0026#34;private\u0026#34;: \u0026#34;bnVsbA==\u0026#34;, \u0026#34;dependencies\u0026#34;: [ \u0026#34;data.intersight_organization_organization.iac\u0026#34; ] } ] } ] } As described this state file above is simply a JSON file following a Terraform specific schema. The state schema includes top-level metadata information such as terraform_version, version (state version), etc. Below this top-level metadata you will find outputs followed by resources.\nResources in State In the state output above, you\u0026rsquo;ll notice there is a root property named resources which contains an array of resource objects. Key properties to note at the start of each resource object are mode, type, and provider.\nData Sources The first resource entry in the state output above contains the following:\n{ \u0026#34;mode\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_organization_organization\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;iac\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;id\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, . . . \u0026#34;results\u0026#34;: [ { . . . \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;IaC_User_{{ pod }}\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, } ], }, \u0026#34;sensitive_attributes\u0026#34;: [] } ] }, Breaking this down we know:\n  mode - is data meaning this is a data source  type - is of resource type intersight_organization_organization  provider - is using the Cisco Intersight provider  The instances -\u0026gt; attributes property contains the returned data fetched from the data source. Each resource regardless of type is always written to state with a unique identifier found in the id property of instances -\u0026gt; attributes. The format of the instance attributes are provider specific and should be well documented within the Terraform registry for that provider -\u0026gt; resource type. In the case of the intersight_organization_organization resource type, all fetched fetched items are stored in an attribute property called results.\nThis entry was written into state because of the following configuration code block:\ndata \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{ pod }}\u0026#34; } This code block tells the Cisco Intersight provider to fetch the details of an Organization with the name IaC_User_. Because the Intersight API always returns a list of results when looking an object up by a property rather than a Moid (Managed object identifier), the matching organization is stored in the results property in the form of a list (array).\nThe first entry in instances -\u0026gt; attributes -\u0026gt; results contains the target organization we want to source data from. Some of the attributes of this result entry have been omitted for readability but the most relevant data point we are after is the moid.\n\u0026#34;results\u0026#34;: [ { . . . \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;IaC_User_2\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, } ], Referencing Data Source Attributes In previous code snippets we have seen how the moid attribute can be referenced in other configuration blocks. Let\u0026rsquo;s look again at the intersight_ntp_policy code below:\nresource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;east_coast\u0026#34; description = \u0026#34;IaC lab NTP policy for east coast\u0026#34; enabled = true ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } When referencing a data source attribute you must always prefix the resource type with data. From there you simply follow the syntax found in state (which should also be well documented in the provider documentation). Generically the format is:\n data. \u0026lt;resource type\u0026gt;. \u0026lt;name\u0026gt;. \u0026lt;attribute path\u0026gt;\nIn this specific example that equates to:\n data. intersight_organization_organization. iac. results[0].moid\nResources Managed resources are always listed after data sources in the state file and are formatted almost identically to a data source with the main exception being the mode attribute is managed instead of data. The resource block shown in the last code snippet above looks like this in the state file:\n{ \u0026#34;mode\u0026#34;: \u0026#34;managed\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_ntp_policy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;east\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;id\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;mod_time\u0026#34;: \u0026#34;2021-09-24 14:31:40.342 +0000 UTC\u0026#34;, \u0026#34;moid\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;east_coast\u0026#34;, \u0026#34;ntp_servers\u0026#34;: [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ], \u0026#34;object_type\u0026#34;: \u0026#34;ntp.Policy\u0026#34;, \u0026#34;organization\u0026#34;: [ { \u0026#34;additional_properties\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;class_id\u0026#34;: \u0026#34;mo.MoRef\u0026#34;, \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;\u0026#34; } ], . . . \u0026#34;timezone\u0026#34;: \u0026#34;Pacific/Niue\u0026#34;, \u0026#34;version_context\u0026#34;: [] }, \u0026#34;sensitive_attributes\u0026#34;: [], \u0026#34;private\u0026#34;: \u0026#34;bnVsbA==\u0026#34;, \u0026#34;dependencies\u0026#34;: [ \u0026#34;data.intersight_organization_organization.iac\u0026#34; ] } ] } Just like with data sources, the format of instances -\u0026gt; attributes is provider specific for the given resource type. In this case, the Cisco Intersight provider formats the attributes of a managed resource slightly differently than a data source. Notice that there is no results attribute in the state output above compared to the data source state entry. This is because the Intersight API does not return a list of results for created objects (POST), only for fetched objects (GET). Cisco chose to preserve that format when writing resources to state with the Intersight provider.\nReferencing Resource Attributes Referencing a managed resource attribute is done almost identically to how a data source attribute is reference with one minor exception, you don\u0026rsquo;t need the data prefix. Therefore, the generic syntax would be:\n \u0026lt;resource type\u0026gt;. \u0026lt;name\u0026gt;. \u0026lt;attribute path\u0026gt;\nWe will see an example of referencing attributes from this managed resource in the following section.\nOutputs in State Output values contain the values you want externally exposed or easily read from the state file. This is why the Terraform state schema always puts these values near the top above resources. Unlike resources, outputs is a JSON object of key/value pairs where each key is the output name and the value contains another JSON object with the output value type and actual value. Notice that for outputs, the Terraform language automatically determines the type and does not require an explicit type definition. Let\u0026rsquo;s now look at how the output configuration block was written to state:\nConfiguration:\noutput \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } State:\n\u0026#34;outputs\u0026#34;: { \u0026#34;ntp_east_moid\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, In the state file you can see that Terraform has retrieved the value of the intersight_ntp_policy. east. moid managed resource attribute shown in the previous section and has also determined that the type of this value is string\nExecution Order As discussed in the Terraform Primer  Configuration Blocks  section, execution order is based upon the dependency mapping order determined during state modelling. This dependency mapping is documented in the state file for resources so that it knows the proper execution order for future resource modification operations.\nReviewing again the full state file we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  { \u0026#34;version\u0026#34;: 4, \u0026#34;terraform_version\u0026#34;: \u0026#34;1.0.6\u0026#34;, \u0026#34;serial\u0026#34;: 2, \u0026#34;lineage\u0026#34;: \u0026#34;e98beb19-8d41-e8d1-36b2-26aedcb09c90\u0026#34;, \u0026#34;outputs\u0026#34;: { \u0026#34;ntp_east_moid\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;mode\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_organization_organization\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;iac\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;id\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, . . . \u0026#34;results\u0026#34;: [ { . . . \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;IaC_User_{{ pod }}\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, } ], }, \u0026#34;sensitive_attributes\u0026#34;: [] } ] }, { \u0026#34;mode\u0026#34;: \u0026#34;managed\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;intersight_ntp_policy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;east\u0026#34;, \u0026#34;provider\u0026#34;: \u0026#34;provider[\\\u0026#34;registry.terraform.io/ciscodevnet/intersight\\\u0026#34;]\u0026#34;, \u0026#34;instances\u0026#34;: [ { \u0026#34;schema_version\u0026#34;: 0, \u0026#34;attributes\u0026#34;: { . . . \u0026#34;id\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;mod_time\u0026#34;: \u0026#34;2021-09-24 14:31:40.342 +0000 UTC\u0026#34;, \u0026#34;moid\u0026#34;: \u0026#34;614de14c6275722d3054c65c\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;east_coast\u0026#34;, \u0026#34;ntp_servers\u0026#34;: [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ], \u0026#34;object_type\u0026#34;: \u0026#34;ntp.Policy\u0026#34;, \u0026#34;organization\u0026#34;: [ { \u0026#34;additional_properties\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;class_id\u0026#34;: \u0026#34;mo.MoRef\u0026#34;, \u0026#34;moid\u0026#34;: \u0026#34;6138396d6972652d3029a3bc\u0026#34;, \u0026#34;object_type\u0026#34;: \u0026#34;organization.Organization\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;\u0026#34; } ], . . . \u0026#34;timezone\u0026#34;: \u0026#34;Pacific/Niue\u0026#34;, \u0026#34;version_context\u0026#34;: [] }, \u0026#34;sensitive_attributes\u0026#34;: [], \u0026#34;private\u0026#34;: \u0026#34;bnVsbA==\u0026#34;, \u0026#34;dependencies\u0026#34;: [ \u0026#34;data.intersight_organization_organization.iac\u0026#34; ] } ] } ] }   On line 84 of the state file you can see Terraform has documented that the intersight_ntp_policy.east managed resource has a dependency on the data.intersight_organization_organization.iac data source. Now when creating, updating, or deleting this configuration Terraform knows the proper order of operations.\nDependency data is not stored for output values because they are always evaluated last. If you have a need for variables that can reference resource attributes, take a look at Local Values\nMoving Forward Now that you know how to properly write configuration code and read it in state, let\u0026rsquo;s look at how to perform lifecycle actions using the Terraform CLI.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/open_source/second_policy/",
	"title": "Create another policy",
	"tags": [],
	"description": "",
	"content": "So far in this lab, you have been copying and pasting either from the lab guide or the online documentation. In this section of the lab, you will create a resource manually but with a lot of help from the Terraform extension for vsCode.\nEnjoy Terraform extension for vsCode The Terraform extension for vsCode is particularly powerful at autocompletion. In this section of the lab, you will explore that.\nSteps:\n Open your ntp.tf file and add a few blank lines at the end. On a new line, just type the letter \u0026ldquo;r\u0026rdquo; and notice that vsCode displays the keyword \u0026ldquo;resource\u0026rdquo; as shown below. Click on the word or press the tab key to autocomplete the resource keyword and a very simple resource block.  Your cursor is automatically placed where resource type is defined and you can see a very long list of resource types for every provider that you have defined (you have only defined one provider in this lab). Start typing \u0026ldquo;intersight_n\u0026rdquo; to see the list get filtered down. Click on \u0026ldquo;intersight_ntp_policy\u0026rdquo;.  Give your new resource a local name such as \u0026ldquo;west\u0026rdquo;. Within the resource block, type the letter \u0026ldquo;n\u0026rdquo; and notice that vsCode displays the two valid parameters for this resource type that begin with the letter \u0026ldquo;n\u0026rdquo;. Click on \u0026ldquo;name\u0026rdquo; and give your policy a name such as \u0026quot;${var.policy_name_prefix}-ntp-west\u0026quot;.  On the next line after the \u0026ldquo;name\u0026rdquo; property, start typing the word \u0026ldquo;description\u0026rdquo; and hit the tab key when it is the top item (or only item) in the popup list. You will see a popup list of values that can be assigned to that property. Notice that \u0026ldquo;var.policy_description\u0026rdquo; is in that list. Click on \u0026ldquo;var.policy_description\u0026rdquo;.  You have defined two properties and will probably notice that the equals signs (=) do not line up like they did in previous code snippets you have used. Formatting is not technically required, but it is more aesthetically pleasing to have those lined up. The Terraform extension can do that for you. Go to the vsCode Command Palette (Ctrl+Shift+P) and type the command \u0026ldquo;Format Document\u0026rdquo;. Your lines will now be lined up. The difference can be seen in the two images below.  Complete the remainder of the resource definition for your second NTP policy. It should look something like the code snippet below. Use the Format Document trick you learned above to make your document more readable. Save the file and run tf apply. Notice that a second NTP policy is created.  resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;west\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-west\u0026#34; description = var.policy_description enabled = true timezone = var.west_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. myvalues.auto.tfvars policy_name_prefix = \u0026#34;iac-lab\u0026#34; policy_description = \u0026#34;created by Terraform\u0026#34; east_timezone = \u0026#34;America/New_York\u0026#34; west_timezone = \u0026#34;America/Los_Angeles\u0026#34;   ntp.tf resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } } resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;west\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-west\u0026#34; description = var.policy_description enabled = true timezone = var.west_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }   outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid } output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{ pod }}\u0026#34; }   variables.tf variable \u0026#34;policy_name_prefix\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;policy_description\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;west_timezone\u0026#34; { description = \u0026#34;timezone used for west NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;intersight_api_secret\u0026#34; { type = string default = \u0026#34;\u0026#34; } variable \u0026#34;intersight_api_key\u0026#34; { type = string default = \u0026#34;\u0026#34; }   Congratulations! You added a second policy to an existing .tf file and learned several tips about using the Terraform extension for vsCode.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/actions/",
	"title": "Actions",
	"tags": [],
	"description": "",
	"content": "Terraform\u0026rsquo;s primary function is to create, modify, and destroy infrastructure resources to match the desired state described in a Terraform configuration.\nWhen people refer to \u0026ldquo;running Terraform\u0026rdquo;, they generally mean performing these provisioning actions in order to affect real infrastructure objects. The Terraform binary has many other subcommands for a wide variety of administrative actions, but these basic provisioning tasks are the core of Terraform.\nTerraform\u0026rsquo;s provisioning workflow relies on four commands: init, plan, apply, and destroy. All of these commands require an initialized working directory, and all of them act only upon the currently selected directory/workspace.\nInitialization The terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times.\nMost Terraform providers are published separately from Terraform as plugins. During init, Terraform searches the configuration for both direct and indirect references to providers and attempts to install the plugins for those providers.\nFor providers that are published in either the public Terraform Registry or in a third-party provider registry, terraform init will automatically find, download, and install the necessary provider plugins.\nPlanning The terraform plan command evaluates a Terraform configuration to determine the desired state of all the resources it declares, then compares that desired state to the real infrastructure objects being managed with the current working directory and workspace. It uses state data to determine which real objects correspond to which declared resources, and checks the current state of each resource using the relevant infrastructure provider\u0026rsquo;s API.\nOnce it has determined the difference between the current state and the desired state, terraform plan presents a description of the changes necessary to achieve the desired state. It does not perform any actual changes to real world infrastructure objects; it only presents a plan for making changes.\nPlans are usually run to validate configuration changes and confirm that the resulting actions are as expected. However, terraform plan can also save its plan as a runnable artifact, which terraform apply can use to carry out those exact changes.\nApplying The terraform apply command performs a plan just like terraform plan does, but then actually carries out the planned changes to each resource using the relevant infrastructure provider\u0026rsquo;s API. It asks for confirmation from the user before making any changes, unless it was explicitly told to skip approval.\nBy default, terraform apply performs a fresh plan right before applying changes, and displays the plan to the user when asking for confirmation. However, it can also accept a plan file produced by terraform plan in lieu of running a new plan. You can use this to reliably perform an exact set of pre-approved changes, even if the configuration or the state of the real infrastructure has changed in the minutes since the original plan was created.\nDestroying The terraform destroy command destroys all of the resources being managed by the current working directory and workspace, using state data to determine which real world objects correspond to managed resources. Like terraform apply, it asks for confirmation before proceeding.\nA destroy behaves exactly like deleting every resource from the configuration and then running an apply, except that it doesn\u0026rsquo;t require editing the configuration. This is more convenient if you intend to provision similar resources at a later date.\nMoving Forward You have now learned how to create, execute and read configuration using Terraform. Lastly, we will look at the various consumption models Hashicorp offers for Terraform.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/tf_cloud/modules/",
	"title": "Use Community Modules",
	"tags": [],
	"description": "",
	"content": "A module can be formally registered with the Terraform Registry or it can simply be a GitHub repository or even a subfolder within your project directory. If you find the need to write a module that others may benefit from, you may choose to publish your module. Sometimes it makes more sense to keep your module private. In this section of the lab, you will locate and use a published module.\nRetrieve existing pools The module that you will use requires references (MOID) to an Intersight IP pool and MAC pool. Recall that much earlier in the lab you obtained a reference to your Intersight organization using a Terraform data source. You will do the same here for the two pools.\nSteps:\n In the Intersight left navigation, browse to Configure -\u0026gt; Pools. Make note of the names of the IP and MAC pools that have been created for you. Update your sources.tf file by adding two data blocks: one for your IP pool and one for your MAC pool. Use your data block for the organization as a reference. You can use the same local name for all three data sources. You simply have to change the resource type and the actual name of the object. There is a checkpoint at the end of this page if you get stuck. Confirm that your syntax is correct by pushing your configuration to GitHub, which will trigger a run in Terraform Cloud. Recall that you must commit your changed file first, then push it to GitHub. If you forget the steps, you can refer back to the last time you pushed changes.  Instantiate a module There is a publicly available module for the Intersight provider that creates roughly two dozen sample policies in Intersight with a small number of inputs.\nSteps:\n Browse to the Intersight provider page on the Terraform Registry. Notice that under the summary of the Intersight provider, there is a section labeled \u0026ldquo;Top downloaded intersight modules\u0026rdquo;. These are modules whose authors have registered their modules with HashiCorp. Click on the module named policy-bundle.  There are several things to note on this page:\n There is a link to the source code for this module on GitHub and a place to report defects. You can look through the module\u0026rsquo;s code if you have questions about what it does. There is a snippet showing how to provision this module, much like the snippet shown in the Registry for provisioning a provider. You will probably find the examples more useful, though. There is a dropdown for Examples showing how to use the module. There are multiple tabs for documentation across the bottom of the page (Readme, Inputs, Outputs, Dependency, Resources). There may be multiple versions for a module as features are added or issues are addressed. There is a dropdown towards the top of the page to select a different version of the module.  Click on Examples and choose minimal. The sample code from the \u0026ldquo;minimal\u0026rdquo; example is nearly identical to the snippet below. Only the references to the organization, MAC pool, and IP pool have changed from the example. Make sure you understand those changes. Copy the code snippet below with and paste it into a new file called policy.tf. Make any appropriate changes to the file and save it. Commit and push your new file. Confirm and Apply the run in Terraform Cloud. In the Intersight left navigation, browse to Configure -\u0026gt; Policies and notice the large number of new policies with very similar names. These were created by the module.  module \u0026#34;intersight_policy_bundle\u0026#34; { source = \u0026#34;terraform-cisco-modules/policy-bundle/intersight\u0026#34;# external sources  organization = data.intersight_organization_organization.iac.results[0].moid vnic_mac_pool = data.intersight_macpool_pool.iac.results[0].moid imc_access_pool = data.intersight_ippool_pool.iac.results[0].moid# every policy created will have this prefix in its name  policy_prefix = \u0026#34;my-first\u0026#34;# Fabric Interconnect 6454 config specifics  server_ports_6454 = [17, 18, 19, 20] port_channel_6454 = [49, 50] uplink_vlans_6454 = { \u0026#34;vlan1020\u0026#34; : 1020, \u0026#34;vlan1021\u0026#34; : 1021 } imc_access_vlan = 1020 imc_admin_password = \u0026#34;Inters!ght\u0026#34; ntp_servers = [\u0026#34;time-a-g.nist.gov\u0026#34;] dns_preferred = \u0026#34;172.16.1.98\u0026#34; } Notice that the documentation for the module inputs shows both required and optional inputs. Not every input used in the module instantiation above is required, meaning that certain parameters could be deleted. Delete the line policy_prefix = \u0026ldquo;my-first\u0026rdquo; from the policy.tf file and trigger another Terraform run (by committing and pushing your code). Notice what happens to the policies that had been created in Terraform. They are all renamed!  At this point in the lab your configuration files should closely match the code blocks below. Please expand the files for reference. myvalues.auto.tfvars policy_name_prefix = \u0026#34;iac-lab\u0026#34; policy_description = \u0026#34;created by Terraform\u0026#34; east_timezone = \u0026#34;America/New_York\u0026#34; west_timezone = \u0026#34;America/Los_Angeles\u0026#34;   ntp.tf resource \u0026#34;intersight_ntp_policy\u0026#34; \u0026#34;east\u0026#34; { name = \u0026#34;${var.policy_name_prefix}-ntp-east\u0026#34; description = var.policy_description enabled = true timezone = var.east_timezone ntp_servers = [ \u0026#34;ntp.esl.cisco.com\u0026#34;, \u0026#34;time-a-g.nist.gov\u0026#34;, \u0026#34;time-b-g.nist.gov\u0026#34; ] organization { object_type = \u0026#34;organization.Organization\u0026#34; moid = data.intersight_organization_organization.iac.results[0].moid } }   outputs.tf output \u0026#34;my_org_moid\u0026#34; { value = data.intersight_organization_organization.iac.results[0].moid } output \u0026#34;ntp_east_moid\u0026#34; { value = intersight_ntp_policy.east.moid } output \u0026#34;ntp_east_timezone\u0026#34; { value = intersight_ntp_policy.east.timezone }   policy.tf module \u0026#34;intersight_policy_bundle\u0026#34; { source = \u0026#34;terraform-cisco-modules/policy-bundle/intersight\u0026#34;# external sources  organization = data.intersight_organization_organization.iac.results[0].moid vnic_mac_pool = data.intersight_macpool_pool.iac.results[0].moid imc_access_pool = data.intersight_ippool_pool.iac.results[0].moid# every policy created will have this prefix in its name  policy_prefix = \u0026#34;my-first\u0026#34;# Fabric Interconnect 6454 config specifics  server_ports_6454 = [17, 18, 19, 20] port_channel_6454 = [49, 50] uplink_vlans_6454 = { \u0026#34;vlan1020\u0026#34; : 1020, \u0026#34;vlan1021\u0026#34; : 1021 } imc_access_vlan = 1020 imc_admin_password = \u0026#34;Inters!ght\u0026#34; ntp_servers = [\u0026#34;time-a-g.nist.gov\u0026#34;] dns_preferred = \u0026#34;172.16.1.98\u0026#34; }   providers.tf terraform { required_providers { intersight = { source = \u0026#34;CiscoDevNet/intersight\u0026#34; version = \u0026#34;1.0.15\u0026#34; } } } provider \u0026#34;intersight\u0026#34; {# Configuration options }   sources.tf data \u0026#34;intersight_organization_organization\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;IaC_User_{{pod}}\u0026#34; } data \u0026#34;intersight_ippool_pool\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;iac-user-{{pod}}-ip-pool\u0026#34; } data \u0026#34;intersight_macpool_pool\u0026#34; \u0026#34;iac\u0026#34; { name = \u0026#34;iac-user-{{pod}}-mac-pool\u0026#34; }   variables.tf variable \u0026#34;policy_name_prefix\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;policy_description\u0026#34; { description = \u0026#34;contents of the description field for policies\u0026#34; type = string } variable \u0026#34;east_timezone\u0026#34; { description = \u0026#34;timezone used for east NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;west_timezone\u0026#34; { description = \u0026#34;timezone used for west NTP policy\u0026#34; type = string default = \u0026#34;America/Chicago\u0026#34; } variable \u0026#34;intersight_api_secret\u0026#34; { type = string default = \u0026#34;\u0026#34; } variable \u0026#34;intersight_api_key\u0026#34; { type = string default = \u0026#34;\u0026#34; }   Congratulations! You used a community-provided Terraform module and its documentation to deploy more than 20 policies with just a few lines of code. Modules are a very powerful construct in Terraform.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/terraform_primer/terraform_offerings/",
	"title": "Terraform Offerings",
	"tags": [],
	"description": "",
	"content": "Terraform is available in three different offerings from Hashicorp today: Terraform OSS, Terraform Enterprise, and Terraform Cloud. Which offering you choose will depend upon things like your operational team size, security needs, version control support, governance needs, etc. Below we will discuss each Terraform offering.\nTerraform OSS (CLI) As mentioned in the Terraform Primer  Core Concepts  section, the core of Terraform\u0026rsquo;s capability is distributed as a standalone executable called Terraform OSS (Open Source Software). Terraform Enterprise and Terraform Cloud wrap additional operational tooling around the Terraform OSS executable but under the hood all three of these offerings ultimately use Terraform OSS to manage infrastructure configuration.\nWhen using Terraform OSS you must take careful consideration around how you choose to store and backup your state files. State files can contain sensitive data in clear text so encrypting those files is critical. If state files were to become corrupt or lost then Terraform has no way to identify the real resources it created during previous runs.\nIf you are learning Terraform, running a quick experiment, or are the only administrator of an environment then Terraform OSS is a good place to start.\nTerraform Cloud  Terraform Cloud is an application that helps teams use Terraform together. It manages Terraform runs in a consistent and reliable environment, and includes easy access to shared state and secret data, access controls for approving changes to infrastructure, a private registry for sharing Terraform modules, detailed policy controls for governing the contents of Terraform configurations, and more.\nTerraform Cloud is available as a hosted service at app.terraform.io. Small teams can sign up for free to connect Terraform to version control, share variables, run Terraform in a stable remote environment, and securely store remote state. Paid tiers allow you to add more than five users, create teams with different levels of permissions, enforce policies before creating infrastructure, and collaborate more effectively.\nThe Business tier allows large organizations to scale to multiple concurrent runs, create infrastructure in private environments, manage user access with SSO, and automates self-service provisioning for infrastructure end users.\nTerraform Enterprise Terraform Enterprise is the self-hosted distribution of Terraform Cloud. It offers enterprises a private instance of the Terraform Cloud application, with no resource limits and with additional enterprise-grade architectural features like audit logging and SAML single sign-on.\nCongratulations! You have now learned the the fundamentals of Terraform and are ready to move on to writing configuration code. Please proceed to the next chapter to start the hands-on portion of this workshop.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": "Reference Material This chapter contains supporting reference material for topics covered within the lab guide. Click on an individual link to learn more.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/",
	"title": "IaC Fundamentals with Intersight",
	"tags": [],
	"description": "",
	"content": "Infrastructure as Code Lab Welcome to Wookie Labs and this lab covering Infrastructre as Code (IaC) Fundamentals with Intersight.\nWhat you will learn In this lab, you will start using Terraform OSS (open source software) from the command line and migrate to using Terraform Cloud, using the Cisco Intersight provider for Terraform for datacenter configuration every step of the way. You will learn:\n how to use the online documenation how to organize your configuration code into multiple files how to define and use variables how manage secrets how to collaborate with your team  Additional resources Throughout this lab there are links to public sites with additional details. If there is any portion of the lab that you don\u0026rsquo;t fully understand, you are encouraged to read those pages.\nAdditionally there are some summaries provided on this site. Clicking on the Resources link in the left navigation bar will take you to those pages.\nGet started Good luck and have fun! When you are ready to get started, click on blue arrow on the right side of the page to proceed.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/resources/guacamole/",
	"title": "Guacamole",
	"tags": [],
	"description": "",
	"content": "This page contains some background about using Guacamole properly.\n"
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/resources/tf_background/",
	"title": "Terraform background",
	"tags": [],
	"description": "",
	"content": "This page contains some background about Terraform providers and modules.\nDefinitions Provider Module State file Configuration Configuration file contents Resource Data Output Variables Commands terraform init terraform plan terraform apply terraform destroy "
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://wookie-labs.github.io/iac-workshop-intersight/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]